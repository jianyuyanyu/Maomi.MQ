# Qos 并发和顺序

基于消费者模式和基于事件模式都是通过特性来配置消费属性，Qos 是其中一个重要的属性。



### Qos 场景

对于消费者模式和事件总线模式，在没有使用 `Group` 属性配置消费行为时，每个队列都会独占一个 IConnection 以及 Host service。

对于消费频率很高但是不能并发的队列，最好不要设置 `Group` 属性，以及务必设置 `Qos = 1`。这样依赖，该消费者会独占资源进行消费，在保证顺序的情况下，独占资源有助于提高消费能力。

```csharp
[Consumer("web1", Qos = 1)]
public class MyConsumer : IConsumer<TestEvent>
{
}
```



当需要需要提高消费吞吐量，而且不需要顺序消费时，可以将 Qos 设置高一些，RabbitMQ Client 框架会通过预取等方式提高吞吐量，并且多条消息可以并发消费。



如果判断一些消费者的消费频率不会很高时，可以将这些消费者放到一个分组中。

当多个消费者或事件配置共用一个分组时，那么这些事件的 Qos 应当一致，否则按照平均值来算。

示例：

```csharp
[Consumer("web1", Qos = 10, Group = "group")]
public class My1Consumer : IConsumer<TestEvent>
{
}

[Consumer("web2", Qos = 6, Group = "group")]
public class My2Consumer : IConsumer<TestEvent>
{
}
```



由于两个消费者使用相同的分组，因此复用通道的 Qos 会被设置为 8。



如果消费频率不高，但是需要顺序消费时，可以将这些消费者放到同一个分组中，并且 Qos 设置为 1。

```csharp
[Consumer("web1", Qos = 1, Group = "group1")]
public class My1Consumer : IConsumer<TestEvent>
{
}

[Consumer("web2", Qos = 1, Group = "group1")]
public class My2Consumer : IConsumer<TestEvent>
{
}
```





### 并发和异常处理

第一次情况，Qos 为 1 时，不设置 ExecptionRequeue 、RetryFaildRequeue。

第二种情况，Qos 为 1 时，设置 ExecptionRequeue 、RetryFaildRequeue。



Qos 为 1 时，会保证严格顺序消费，ExecptionRequeue 、RetryFaildRequeue 会影响失败的消息是否会被放回队列，如果放回队列，下一次消费会继续消费之前失败的消息。如果错误（如 bug）得不到解决，则会出现消费、失败、放回队列、重新消费这样的循环。



第三次情况，Qos > 1 时，不设置 ExecptionRequeue 、RetryFaildRequeue。

第四种情况，Qos > 1 时，设置 ExecptionRequeue 、RetryFaildRequeue。



当 Qos 大于 1 时，如果设置了  `RetryFaildRequeue = true`，那么消费失败的消息会被放回队列中，但是不一定下一次会立即重新消费该条消息。



### 如何设置 Qos 

Qos 指 prefetch_count，为 0 时不限制，取值范围是 0-65535。

prefetch_count 是消费者连接 RabbitMQ 时的参数，是由 RabbitMQ 控制推送消息的速度和数量。

Qos 不等于消费者并发线程数量。

RabbitMQ 默认 Qos = 0 = 100



根据官方表

| Prefetch limit预取限制 | Consumer utilisation消费者使用率 |
| ---------------------- | -------------------------------- |
| 1                      | 14%                              |
| 3                      | 25%                              |
| 10                     | 46%                              |
| 30                     | 70%                              |
| 1000                   | 74%                              |

[Finding bottlenecks with RabbitMQ 3.3 | RabbitMQ](https://www.rabbitmq.com/blog/2014/04/14/finding-bottlenecks-with-rabbitmq-3-3)



应当综合考虑机器网络带宽、每条消息的大小、发布消息的频率、估算程序整体占用的资源等。

当程序需要严格顺序消费时，或者发布消息的频率不高时，可以设置为 1。

如果在内网连接 RabbitMQ 可以无视网络带宽限制，消息的内容十分大、需要极高的并发量时，可以设置 Qos = 30。

一般情况下需要开发者中综合各类因素去配置 Qos。

当 Qos = 0 时，RabbitMQ.Client 会尽可能吃掉机器的性能，请谨慎使用。



### Qos 和消费性能测试

定义事件：

```csharp
public class TestEvent
{
    public int Id { get; set; }
    public string Message { get; set; }
    public int[] Data { get; set; }

    public override string ToString()
    {
        return Id.ToString();
    }
}
```



发布消息：

```csharp
int totalCount = 0;
List<Task> tasks = new();
var message = string.Join(",", Enumerable.Range(0, 100));
var data = Enumerable.Range(0, 100).ToArray();
for (var i = 0; i < 10; i++)
{
	var task = Task.Factory.StartNew(async () =>
	{
		var singlePublisher = _messagePublisher.CreateSingle();

		for (int k = 0; k < 100000; k++)
		{
			var count = Interlocked.Increment(ref totalCount);
			await singlePublisher.PublishAsync(queue: "qos", message: new TestEvent
			{
				Id = count,
				Message = message,
				Data = data
			});
		}
	});
	tasks.Add(task);
}

await Task.WhenAll(tasks);
```



现在服务器已经有 100w 条消息了。

![image-20240621130733745](./images/image-20240621130733745.png)



创建消费者，人为给消费者增加 50ms 的耗时，消息内容约 800 byte，小于 1k：

```csharp
class Program
{
    static async Task Main()
    {
        var host = new HostBuilder()
            .ConfigureLogging(options =>
            {
                options.AddConsole();
                options.AddDebug();
            })
            .ConfigureServices(services =>
            {
                services.AddMaomiMQ(options =>
                {
                    options.WorkId = 1;
                    options.AppName = "myapp-consumer";
                    options.Rabbit = (options) =>
                    {
                        options.HostName = "10.1.0.4";
                        options.ClientProvidedName = Assembly.GetExecutingAssembly().GetName().Name;
                    };
                }, new System.Reflection.Assembly[] { typeof(Program).Assembly });

            }).Build();

        Console.WriteLine($"启动时间:{DateTime.Now}");
        await host.RunAsync();
    }
}


[Consumer("qos", Qos = 30)]
public class QosConsumer : IConsumer<TestEvent>
{
    private static int Count = 0;
    public async Task ExecuteAsync(EventBody<TestEvent> message)
    {
        Interlocked.Increment(ref Count);
        Console.WriteLine($"date time:{DateTime.Now},id:{message.Body.Id}, count:{Count}");
        await Task.Delay(50);
    }

    public Task FaildAsync(Exception ex, int retryCount, EventBody<TestEvent>? message)
    {
        return Task.CompletedTask;
    }

    public Task<bool> FallbackAsync(EventBody<TestEvent>? message)
    {
        return Task.FromResult(true);
    }
}
```



以 Release 发布程序，然后启动十个进程。

```csharp
using System.Diagnostics;

async Task Main()
{
	var psi = new ProcessStartInfo(@"qos\QosConsole\bin\Release\net8.0\publish\QosConsole.exe")
	{
		UseShellExecute = true,
		CreateNoWindow = false
	};

	List<Task> tasks = new();

	for (int i = 0; i < 10; i++)
	{
		var task = async () =>
		{
			var ps = Process.Start(psi);
			await ps.WaitForExitAsync();
		};
		tasks.Add(task.Invoke());
	}

	await Task.WhenAll(tasks);
}

```



笔者使用的是 Windows 虚拟机，性能不高。

![image-20240621144440699](./images/image-20240621144440699.png)





Qos = 0 时，10 个进程一起消费，并且人为设置每个消息处理耗时 50ms，耗时 3分30秒即 210 秒(包括程序启动时间)消费完 100w条消息 。

从下图可以看到，由于笔者的虚拟机 CPU 性能不高，程序在处理消息时需要进行反序列化，这一步非常消耗 CPU 性能，其实内存也一直在上升，只是在任务管理器里面没那么直观。当然，进程数量并不是越多消费越快。另外，由于 RabbitMQ 的分配机制以及客户端程序的性能，有的消费者可能会很快就消费完毕，有的消费者在后面很长一段时间内继续处理消息。

![image-20240621234445414](./images/image-20240621234445414.png)



直接在 VS 里面观察，会发现内存会持续上升。

![image-20240621235157310](./images/image-20240621235157310.png)

一开始笔者以为是自己的代码问题，后来经过排查，发现是 RabbitMQ 自身的原因，可以参考 RabbitMQConsole 中的示例。

![image-20240621235740723](./images/image-20240621235740723.png)



10 进程，每个消息手动设置 50ms。

> 以下时间包括了启动 10 个进程的时间，大概需要 15s 才能启动完毕所有进程。

| Qos  | RabbitMQ.Client | Maomi.MQ.RabbitMQ |
| ---- | --------------- | ----------------- |
| 0    | 140s            | 230s              |
| 30   | 300s            | 230s              |
| 100  | 140s            | 220s              |
| 1000 | 150s            | 210s              |



笔者虚拟机最大的性能瓶颈是 CPU，

根据以上测试结果可以发现，Qos = 100 时，消费速度最快，大于 100 时基本没有什么提升了。

Qos = 30 时，RabbitMQ.Client 比 Maomi.MQ.RabbitMQ 还慢，一开始觉得不合理，测试了好几次都是 RabbitMQ.Client 更慢一些。原因是多 10 个进程消耗的资源比较大，并且 RabbitMQ 要分配推送消息到 10 个进程的速度也不够快，Maomi.MQ.RabbitMQ 快一些的原因在于某些进程消费到 6w多之后就不再消费了，RabbitMQ 只给其他进程推送，反而速度快多了。



